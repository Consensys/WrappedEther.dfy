include "../evm-dafny/src/dafny/evm.dfy"
include "../evm-dafny/src/dafny/core/code.dfy"
include "weth_0_header.dfy"

module symbol {
	import opened Opcode
	import opened Code
	import opened Memory
	import opened Bytecode
	import opened Header

	method block_0_0x02e2(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x02e2
	// Free memory pointer
	requires st'.MemSize() >= 0x60 && st'.Read(0x40) == 0x60
	// Stack height(s)
	requires st'.Operands() == 1
	// Termination
  	requires st'.Load(0x01) == 4 * 2 // length of "WETH", shifted left.   
	{
		var st := st';
		//|fp=0x0060|0x2e1a7d4d| // fn 0x2e1a7d4d "withdraw(uint256)"
		st := JumpDest(st);
		//|fp=0x0060|callSig|
		st := CallValue(st);
		//|fp=0x0060|callVal,callSig|
		st := IsZero(st);
		//|fp=0x0060|callVal==0,callSig|
		st := Push2(st,0x02ed);
		//|fp=0x0060|0x2ed,callVal==0,callSig|
		assume {:axiom} st.IsJumpDest(0x2ed);
		st := JumpI(st);
		if st.PC() == 0x2ed {st := block_0_0x02ed(st); return st;} // call value is zero
		//|fp=0x0060|_|
		st := Push1(st,0x00);
		//|fp=0x0060|0x00,_|
		st := Dup(st,1);
		//|fp=0x0060|0x00,0x00,_|
		st := Revert(st); // revert if call value not zero
		return st;
	}

	method block_0_0x02ed(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x02ed
	// Free memory pointer
	requires st'.MemSize() >= 0x60 && st'.Read(0x40) == 0x60
	// Stack height(s)
	requires st'.Operands() == 1
	// Termination
  	requires st'.Load(0x01) == 4 * 2 // length of "WETH", shifted left.        
	{
		var st := st';
		//|fp=0x0060|callSig|
		st := JumpDest(st);
		//|fp=0x0060|callSig|
		st := Push2(st,0x02f5);
		//|fp=0x0060|0x2f5,callSig|
		st := Push2(st,0x0b30);
		//|fp=0x0060|0xb30,0x2f5,callSig|
		assume {:axiom} st.IsJumpDest(0xb30);
		st := Jump(st);
		//|fp=0x0060|0x2f5,callSig|
		st := block_0_0x0b30(st);
		return st;
	}

	method block_0_0x02f5(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x02f5
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  
	// Stack height(s)
	requires st'.Operands() == 3
	// Static stack items
	requires (st'.Peek(0) == 0x60 && st'.Peek(1) == 0x2f5)
	// Termination	
  	//requires st'.Read(0x60) <= 0xffff    
	{
		var st := st';
		// ||0x60,0x2f5,callSig|
		st := JumpDest(st);
		// ||0x60,0x2f5,callSig|
		st := Push1(st,0x40);
		// ||0x40,0x60,0x2f5,callSig|
		st := MLoad(st);
		// ||0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		// ||0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		// ||0xa0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push1(st,0x20);
		// ||0x20,0xa0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// ||0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,3);
		// ||0xa0,0xc0,0xa0,0xa0,0x60,0x2f5,callSig| 
		assert (st.Peek(0) == 0xa0 && st.Peek(1) == 0xc0 && st.Peek(2) == 0xa0 && st.Peek(3) == 0xa0 && st.Peek(4) == 0x60 && st.Peek(5) == 0x2f5);
		st := block_0_0x02ff(st);  
		return st;
	}

	method block_0_0x02ff(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x02ff
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  
	// Stack height(s)
	requires st'.Operands() == 7
	// Static stack items
	requires (st'.Peek(0) == 0xa0 && st'.Peek(1) == 0xc0 && st'.Peek(2) == 0xa0 && st'.Peek(3) == 0xa0 && st'.Peek(4) == 0x60 && st'.Peek(5) == 0x2f5)
	//requires st'.Peek(0) <= st'.Peek(1)
	// Termination	
	//requires var p := st'.Peek(2); p >= 0x80 // && st'.Peek(1) == p + 0x20
	//requires var q := st'.Peek(1); q >= 0x80  
  	//requires st'.Read(0x60) <= 0xffff  
	{
		var st := st';
		// ||0xa0,0xc0,0xa0,0xa0,0x60,0x2f5,callSig| 
		st := Dup(st,2);
		// ||0xc0,0xa0,0xc0,0xa0,0xa0,0x60,0x2f5,callSig| 
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		assert {:split_here} true;
		// ||0x20,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|  
		st := Dup(st,3);
		// ||0xa0,0x20,0xc0,0xa0,0xa0,0x60,0x2f5,callSig| 
		assert (st.Peek(0) == 0xa0 && st.Peek(1) == 0x20);
		st := MStore(st);   
		// ||0xc0,0xa0,0xa0,0x60,0x2f5,callSig|  i.e. st.Read(0xa0) == 0x20
		assert {:split_here} true;
		//assert sst.Read(0xa0) == 0x20;
		assert (st.Peek(0) == 0xc0  && st.Peek(1) == 0xa0  && st.Peek(2) == 0xa0 && st.Peek(3) == 0x60 && st.Peek(4) == 0x2f5);
		st := Dup(st,4);
		//assert (st.Peek(0) == 0x60  && st.Peek(1) == 0xc0  && st.Peek(2) == 0xa0  && st.Peek(3) == 0xa0 && st.Peek(4) == 0x60 && st.Peek(5) == 0x2f5);
		// ||0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// ||0xc0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// ||0x60,0xc0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := MLoad(st);
		// ||0x04,0xc0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|   i.e. st.Read(0x60) == 0x04
		//assert && st.Read(0x40) == 0xa0 && st.Read(0x60) == 0x04  && st.Read(0x0) == 0x1 && st.Read(0xa0) == 0x20;
		assert (st.Peek(0) == 0x04 && st.Peek(1) == 0xc0 && st.Peek(2) == 0x60 && st.Peek(3) == 0xc0  && st.Peek(4) == 0xa0  && st.Peek(5) == 0xa0 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := block_0_0x0307(st);
		return st;
	}

	method block_0_0x0307(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0307
	// Stack height(s)
	requires st'.Operands() == 9
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  //&& st'.Read(0xa0) == 0x20
	
	//requires st'.MemSize() >= 0x80 && 0x80 <= st'.Read(0x40) <= 0xffff   
	//requires st'.Read(0x40) as nat <= (st'.Read(0x60) as nat + st'.Peek(1) as nat + 0x20)  
	
	// Static stack items
	requires (st'.Peek(0) == 0x04 && st'.Peek(1) == 0xc0 && st'.Peek(2) == 0x60 && st'.Peek(3) == 0xc0  && st'.Peek(4) == 0xa0  && st'.Peek(5) == 0xa0 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5)
	//requires (st'.Peek(2) == 0x60 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5)
	//requires st'.Peek(1) <= (MAX_U256 as u256) - 0x20
	// Termination	
	//requires var p := st'.Peek(1); p >= 0x80
  	//requires st'.Read(0x60) <= 0xffff
	{
		var st := st';
		// ||0x04,0xc0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// ||0xc0,0x04,0xc0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert st.Peek(0) == 0xc0 && st.Peek(1) == 0x04;
		st := MStore(st);
		// ||0xc0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig| i.e. st.MemSize() >= 0xe0 && st.Read(0xc0) == 0x04
		assert {:split_here} true;
		//assert (st.Peek(0) == 0xc0 && st.Peek(1) == 0x60 && st.Peek(2) == 0xc0 && st.Peek(3) == 0xa0 && st.Peek(4) == 0xa0 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		st := Push1(st,0x20);
		// ||0x20,0xc0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) == 0x20 && st.Peek(1) == 0xc0);
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// ||0xe0,0x60,0xc0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert {:split_here} true;
		assert st.Peek(0) == 0xe0;
		//assert (st.Peek(0) == 0xe0 && st.Peek(1) == 0x60 && st.Peek(2) == 0xc0 && st.Peek(3) == 0xa0 && st.Peek(4) == 0xa0 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		st := Swap(st,2);
		// ||0xc0,0x60,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		//assert (st.Peek(0) == 0x60 && st.Peek(1) == 0xe0 && st.Peek(2) == 0xa0 && st.Peek(3) == 0xa0 && st.Peek(4) == 0x60 && st.Peek(5) == 0x2f5);
		// ||0x60,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		// ||0x60,0x60,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := MLoad(st);
		// |0x04,0x60,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) == 0x04 && st.Peek(1) == 0x60 && st.Peek(2) == 0xe0 && st.Peek(3) == 0xa0 && st.Peek(4) == 0xa0 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		//assert st.MemSize() >= 0xe0 && st.Read(0x40) == 0xa0 && st.Read(0x60) == 0x04  && st.Read(0x0) == 0x1 && st.Read(0xa0) == 0x20 && st.Read(0xc0) == 0x04;
		st := block_0_0x0310(st);
		return st;
	}

	method block_0_0x0310(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0310
	// Stack height(s)
	requires st'.Operands() == 8
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  //&& st'.Read(0xa0) == 0x20 && st'.Read(0xc0) == 0x04
	
	//requires st'.MemSize() >= 0x80 && 0x80 <= st'.Read(0x40) <= 0xffff  
	//requires st'.Read(0x40) as nat <= (st'.Peek(0) as nat + st'.Peek(2) as nat) 
	// Static stack items
	requires (st'.Peek(0) == 0x04 && st'.Peek(1) == 0x60 && st'.Peek(2) == 0xe0 && st'.Peek(3) == 0xa0 && st'.Peek(4) == 0xa0 && st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5)
  	//requires var x := st'.Peek(0); x == st'.Read(0x60) <= 0xffff
	{
		var st := st';
		// |0x04,0x60,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// |0x60,0x04,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push1(st,0x20);
		// |0x20,0x60,0x04,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// |0x80,0x04,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// |0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		// |0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,4);
		// |0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,4);
		// |0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push1(st,0x00);
		// |0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := block_0_0x031a(0,st); 
		return st;
	}

	// from 310: |0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
	// from 32d: |0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
	method block_0_0x031a(i: nat, st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x031a
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 12
	// Static stack items
	requires (st'.Peek(1) == 0x80 && st'.Peek(2) == 0xe0 && st'.Peek(3) == 0x04 && st'.Peek(4) == 0x04
			&& st'.Peek(5) == 0x80 && st'.Peek(6) == 0xe0 && st'.Peek(7) == st'.Peek(8) == 0xa0
			&& st'.Peek(9) == 0x60 && st'.Peek(10) == 0x2f5)
	
  	// Termination
	requires var y := st'.Peek(0); y as nat == 0x20 * i
  	requires var x := st'.Peek(3); x <= 0xffff
 	requires var x := st'.Peek(3); var y := st'.Peek(0); y <= (x+0x1f)
	decreases var x := st'.Peek(3); var y := st'.Peek(0); (x+0x1f) - y,2

	{
		var st := st';
		// from 310: |0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// from 32d: |0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := JumpDest(st);
		// from 310: |0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// from 32d: |0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,4);
		// from 310: |0x04,0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// from 32d: |0x04,0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		//assert (st.Peek(5) == 0x04 && st.Peek(7) == 0xe0 && st.Peek(8) == st.Peek(9) == 0xa0 && st.Peek(10) == 0x60 && st.Peek(11) == 0x2f5);
		st := Dup(st,2);
		// from 310: |0x0,0x04,0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// from 32d: |0x20*i,0x04,0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Lt(st);
		// from 310: |1,0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// from 32d: |0,0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert st.Peek(2) == 0x80;
		st := IsZero(st);
		// from 310: |0,0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// from 32d: |1,0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push2(st,0x0335);
		// from 310: |0x335,0,0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// from 32d: |0x335,1,0x20*i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(3) == 0x80 && st.Peek(4) == 0xe0 && st.Peek(5) == 0x04 == 0x04 && st.Peek(7) == 0x80 && st.Peek(8) == 0xe0 && st.Peek(10) == 0xa0 && st.Peek(11) == 0x60 && st.Peek(12) == 0x2f5);
		assume {:axiom} st.IsJumpDest(0x335);
		st := JumpI(st);
		if st.PC() == 0x335 { 
			// from 32d: |0x80,0x20*i,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
			assert (st.Peek(4) == 0x04 && st.Peek(6) == 0xe0 && st.Peek(7) == st.Peek(8) == 0xa0 && st.Peek(9) == 0x60 && st.Peek(10) == 0x2f5);
			st := block_0_0x0335(st); 
			return st;
		} 
		// assert st'.Peek(0) < st'.Peek(3);
		// from 310: |0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		// from 310: |0x0,0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(2) == 0x80 && st.Peek(3) == 0xe0 && st.Peek(4) == st.Peek(5) == 0x04
			&& st.Peek(6) == 0x80 && st.Peek(7) == 0xe0 && st.Peek(8) == st.Peek(9) == 0xa0
			&& st.Peek(10) == 0x60 && st.Peek(11) == 0x2f5);
		assert st.Peek(0) as nat == st.Peek(1) as nat  == i * 20;
		st := block_0_0x0324(i,st);
		return st;
	}

	method block_0_0x0324(i: nat, st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0324
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 13
	// Static stack items
	requires (st'.Peek(2) == 0x80 && st'.Peek(3) == 0xe0 && st'.Peek(4) == 0x04 && st'.Peek(5) == 0x04
			&& st'.Peek(6) == 0x80 && st'.Peek(7) == 0xe0 && st'.Peek(8) == st'.Peek(9) == 0xa0
			&& st'.Peek(10) == 0x60 && st'.Peek(11) == 0x2f5)
	requires st'.Peek(0)  == st'.Peek(1)
	
	//requires st'.MemSize() >= 0x80 && st'.Read(0x40) as nat <= (st'.Peek(5) as nat + st'.Peek(7) as nat) 
 	// Termination
	requires var y := st'.Peek(0); y as nat == i * 0x20
	requires var x := st'.Peek(4); var y := st'.Peek(0); y < x <= 0xffff
	decreases var x := st'.Peek(4); var y := st'.Peek(0); x-y,1
	{
		var st := st';
		// from 310: |0x0,0x0,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		// |y,y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,3);
		// |0x80,y,y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert st.Peek(0) == 0x80 && st.Peek(1) == st'.Peek(0);
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		assert {:split_here} true;
		// |0x80+y,y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := MLoad(st);
		// |Read(0x80+y),y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// |y,Read(0x80+y),y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
    	st := Dup(st,5);
		// |0xe0,y,Read(0x80+y),y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert st.Peek(0) == 0xe0 && st.Peek(1) == st'.Peek(0) <= 0xffff;
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		assert {:split_here} true;
		assert (st.Peek(3) == 0x80 && st.Peek(4) == 0xe0 && st.Peek(5) == 0x04 && st.Peek(6) == 0x04
			&& st.Peek(7) == 0x80 && st.Peek(8) == 0xe0 && st.Peek(9) == st.Peek(10) == 0xa0
			&& st.Peek(11) == 0x60 && st.Peek(12) == 0x2f5);
		// |0xe0+y,Read(0x80+y),y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
    	assert st.Peek(3) == st.Peek(7) == 0x80;    
		st := MStore(st);
		assert {:split_here} true;
		// |y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|  i.e. Read(0xe0+y)==Read(0x80+y),
		st := Push1(st,0x20);
		// |0x20,y,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) == 0x20 && st.Peek(2) == 0x80 && st.Peek(3) == 0xe0 && st.Peek(4) == 0x04 && st.Peek(5) == 0x04
			&& st.Peek(6) == 0x80 && st.Peek(7) == 0xe0 && st.Peek(8) == st.Peek(9) == 0xa0
			&& st.Peek(10) == 0x60 && st.Peek(11) == 0x2f5);
		//assert st.Peek(1)  == st'.Peek(0);
		//st := block_0_0x032d(i,st);
		return st;
	}

	method block_0_0x032d(i: nat, st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x032d
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 13
	// Static stack items
	//requires (st'.Peek(0) == 0x20 && st'.Peek(2) == 0x80 && st'.Peek(6) == 0x80 && st'.Peek(10) == 0x60 && st'.Peek(11) == 0x2f5)
	requires (st'.Peek(0) == 0x20 && st'.Peek(2) == 0x80 && st'.Peek(3) == 0xe0 && st'.Peek(4) == 0x04 && st'.Peek(5) == 0x04
			&& st'.Peek(6) == 0x80 && st'.Peek(7) == 0xe0 && st'.Peek(8) == st'.Peek(9) == 0xa0
			&& st'.Peek(10) == 0x60 && st'.Peek(11) == 0x2f5)
	
	// Termination
	requires var y := st'.Peek(1); y as nat == i * 0x20
	requires var x := st'.Peek(4); var y := st'.Peek(1); y < x <= 0xffff
	decreases var x := st'.Peek(4); var y := st'.Peek(1); x-y,0
	{
		var st := st';
		// |0x20,i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig| 
		st := Dup(st,2);
		// |i,0x20,i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig| 
		//assert st.Peek(5) == st'.Peek(4) && st.Peek(7) == 0x80;
		st := Add(st);
		// |0x20+i,i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// |i,0x20+i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		// |0x20+i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push2(st,0x031a);
		// |0x31a,0x20+i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assume {:axiom} st.IsJumpDest(0x31a);
		st := Jump(st);
		// |0x20+i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(1) == 0x80 && st.Peek(2) == 0xe0 && st.Peek(3) == 0x04 && st.Peek(4) == 0x04
			&& st.Peek(5) == 0x80 && st.Peek(6) == 0xe0 && st.Peek(7) == st.Peek(8) == 0xa0
			&& st.Peek(9) == 0x60 && st.Peek(10) == 0x2f5);
		st := block_0_0x031a(i+1,st);
		return st;
	}

	// from 31a, i...: |0x80,0x20*i,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
	method block_0_0x0335(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0335
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 12
	// Static stack items
	requires (st'.Peek(4) == 0x04 && st'.Peek(6) == 0xe0 && st'.Peek(7) == st'.Peek(8) == 0xa0 && st'.Peek(9) == 0x60 && st'.Peek(10) == 0x2f5)

	{
		var st := st';
		// |i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := JumpDest(st);
		// |i,0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		// |0x80,0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		// |0xe0,0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		// |0x04,0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		// |0x04,0x80,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// |0x80,0x04,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		// |0x04,0xe0,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// |0xe0,0x04,0xa0,0xa0,0x60,0x2f5,callSig|
		st := block_0_0x033d(st);
		return st;
	}

	method block_0_0x033d(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x033d
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 7
	// Static stack items
	requires (st'.Peek(0) == 0xe0 && st'.Peek(1) == 0x04 && st'.Peek(2) == st'.Peek(3) == 0xa0 && st'.Peek(4) == 0x60 && st'.Peek(5) == 0x2f5)
	
	{
		var st := st';
		// |0xe0,0x04,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// |0x04,0xe0,0x04,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		assert {:split_here} true;
		assert (st.Peek(2) == st.Peek(3) == 0xa0 && st.Peek(4) == 0x60 && st.Peek(5) == 0x2f5);
		// |0xe4,0x04,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// |0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push1(st,0x1f);
		// |0x1f,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := AndU5(st);
		// |0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		// |0x04,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := IsZero(st);
		// |0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push2(st,0x0362);
		//||0x0362,0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) == 0x362 && st.Peek(1) == 0 && st.Peek(2) == 0x04 && st.Peek(3) == 0xe4);
		assert (st.Peek(4) == st.Peek(5) == 0xa0  && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := block_0_0x0348(st);
		return st;
	}

	method block_0_0x0348(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0348
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 9
	// Static stack items
	requires (st'.Peek(0) == 0x362 && st'.Peek(1) == 0 && st'.Peek(2) == 0x04 && st'.Peek(3) == 0xe4 && st'.Peek(4) == st'.Peek(5) == 0xa0 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5) 
	{
		var st := st';
		//||0x0362,0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assume {:axiom} st.IsJumpDest(0x362);
		st := JumpI(st);
		if st.PC() == 0x362 { 
			assert false; // Dead code
			//||0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
			st := block_0_0x0362(st); 
			return st;
		}
		//assert st'.Peek(1) == 0;
		//||0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		//||0x04,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,3);
		//||0xe4,0x04,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert st.Peek(0) == 0xe4 && st.Peek(1) == 0x04; 
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		assert {:split_here} true;
		assert st.Peek(0) == 0xe0 && st.Peek(1) == 0x04 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5;
		//||0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,1);
		//||0xe0,0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := MLoad(st);
		//||Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push1(st,0x01);
		//||0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,4);
		//||0x04,0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert st.Peek(0) == 0x04 && st.Peek(1) == 0x1 && st.Peek(3) == 0xe0 && st.Peek(5) == 0xe4 && st.Peek(6) == st.Peek(7) == 0xa0  && st.Peek(8) == 0x60 && st.Peek(9) == 0x2f5;
		st := block_0_0x0351(st);
		return st;
	}

	method block_0_0x0351(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0351
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 11
	// Static stack items
	requires (st'.Peek(0) == 0x04 && st'.Peek(1) == 0x1 && st'.Peek(3) == 0xe0 && st'.Peek(5) == 0xe4 && st'.Peek(6) == st'.Peek(7) == 0xa0 && st'.Peek(8) == 0x60 && st'.Peek(9) == 0x2f5)
	{
		var st := st';
		//||0x04,0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push1(st,0x20);
		//||0x20,0x04,0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		assert {:split_here} true;
		assert (st.Peek(1) == 0x1 && st.Peek(3) == 0xe0 && st.Peek(5) == 0xe4 && st.Peek(6) == st.Peek(7) == 0xa0 && st.Peek(9) == 0x2f5);
		//||0x1c,0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Push2(st,0x0100);
		//||0x100,0x1c,0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Exp(st);
		//||0x100**0x1c,0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(1) == 0x01 && st.Peek(3) == 0xe0 && st.Peek(5) == 0xe4 && st.Peek(6) == st.Peek(7) == 0xa0 && st.Peek(9) == 0x2f5);
		assume st.Peek(0) >= 0x01; // i.e. result of exp is at least 1
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		assert {:split_here} true;
		assert (st.Peek(2) == 0xe0 && st.Peek(4) == 0xe4 && st.Peek(5) == st.Peek(6) == 0xa0 && st.Peek(8) == 0x2f5);
		//||(0x100**0x1c)-0x01,Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Not(st);
		//||!((0x100**0x1c)-0x01),Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := And(st);
		//||!((0x100**0x1c)-0x01)&Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Dup(st,2);
		//||0xe0,!((0x100**0x1c)-0x01)&Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) == st.Peek(2) == 0xe0 && st.Peek(4) == 0xe4 && st.Peek(5) == st.Peek(6) == 0xa0 && st.Peek(8) == 0x2f5);
		st := block_0_0x035c(st);
		return st;
	}

	method block_0_0x035c(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x035c
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 10
	// Static stack items
	requires (st'.Peek(0) == st'.Peek(2) == 0xe0 && st'.Peek(4) == 0xe4 && st'.Peek(5) == st'.Peek(6) == 0xa0 && st'.Peek(8) == 0x2f5) 
	{
		var st := st';
		//||0xe0,!((0x100**0x1c)-0x01)&Read(0xe0),0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		st := MStore(st);
		//||0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert {:split_here} true;
		assert (st.Peek(2) == 0xe4 && st.Peek(3) == 0xa0 && st.Peek(6) == 0x2f5);
		st := Push1(st,0x20);
		//||0x20,0xe0,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		//||0x100,0x04,0xe4,0xa0,0xa0,0x60,0x2f5,callSig|
		assert {:split_here} true;
		assert (st.Peek(0) == 0x100 && st.Peek(3) == 0xa0 && st.Peek(6) == 0x2f5);
		st := Swap(st,2);
		//||0xe4,0x04,0x100,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		//||0x04,0x100,0xa0,0xa0,0x60,0x2f5,callSig|
		assert (st.Peek(1) == 0x100 && st.Peek(2) == 0xa0 && st.Peek(5) == 0x2f5);
		st := block_0_0x0362(st);
		return st;
	}

	method block_0_0x0362(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0362
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 7
	// Static stack items
	requires (st'.Peek(1) == 0x100 && st'.Peek(2) == 0xa0 && st'.Peek(5) == 0x2f5)
	{
		var st := st';
		//||0x04,0x100,0xa0,0xa0,0x60,0x2f5,callSig|
		st := JumpDest(st);
		//||0x04,0x100,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Pop(st);
		//||0x100,0xa0,0xa0,0x60,0x2f5,callSig|
		st := Swap(st,3);
		//||0x60,0xa0,0xa0,0x100,0x2f5,callSig|
		st := Pop(st);
		//||0xa0,0xa0,0x100,0x2f5,callSig|
		st := Pop(st);
		//||0xa0,0x100,0x2f5,callSig|
		st := Pop(st);
		//||0x100,0x2f5,callSig|
		st := Push1(st,0x40);
		//||0x40,0x100,0x2f5,callSig|
		st := MLoad(st);
		//||0xa0,0x100,0x2f5,callSig|
		assert (st.Peek(0) == 0xa0 && st.Peek(1) == 0x100 && st.Peek(2) == 0x2f5);
		st := block_0_0x036b(st);
		return st;
	}

	method block_0_0x036b(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x036b
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 
	// Stack height(s)
	requires st'.Operands() == 4
	// Static stack items
	requires (st'.Peek(0) == 0xa0 && st'.Peek(1) == 0x100 && st'.Peek(2) == 0x2f5)
	{
		var st := st';
		//||0xa0,0x100,0x2f5,callSig|
		st := Dup(st,1);
		//||0xa0,0xa0,0xe4,0x2f5,callSig|
		st := Swap(st,2);
		//||0x100,0xa0,0xa0,0x2f5,callSig|
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		//||0x60,0xa0,0x2f5,callSig|
		st := Swap(st,1);
		//||0xa0,0x60,0x2f5,callSig|
		st := Return(st);
		return st;
	}

	method block_0_0x0b30(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b30
	// Free memory pointer
	requires st'.MemSize() >= 0x60 && st'.Read(0x40) == 0x60
	// Stack height(s)
	requires st'.Operands() == 2
	// Static stack items
	requires (st'.Peek(0) == 0x2f5)
	// Termination
  	requires st'.Load(0x01) == 4 * 2 // length of "WETH", shifted left.      
	{
		var st := st';
		//|fp=0x0060|0x2f5,callSig|
		st := JumpDest(st);
		//|fp=0x0060|0x2f5,callSig|
		st := Push1(st,0x01);
		//|fp=0x0060|0x01,0x2f5,callSig|
		st := Dup(st,1);
		//|fp=0x0060|0x01,0x01,0x2f5,callSig|
		st := SLoad(st);
		//|fp=0x0060|0x08,0x01,0x2f5,callSig|
		st := Push1(st,0x01);
		//|fp=0x0060|0x01,0x08,0x01,0x2f5,callSig|
		st := Dup(st,2);
		//|fp=0x0060|0x08,0x01,0x08,0x01,0x2f5,callSig|
		st := Push1(st,0x01);
		//|fp=0x0060|0x01,8,0x01,0x08,0x01,0x2f5,callSig|
		st := AndU1(st);
		//|fp=0x0060|0,0x01,0x08,0x01,0x2f5,callSig| // i.e. first bit of Load(0x01) is 0
		st := block_0_0x0b3b(st);
		return st;
	}

	method block_0_0x0b3b(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b3b
	// Free memory pointer
	requires st'.MemSize() >= 0x60 && st'.Read(0x40) == 0x60
	// Stack height(s)
	requires st'.Operands() == 6
	// Static stack items
  	requires st'.Peek(0) == 0
  	requires st'.Peek(2) == st'.Load(0x01)
	requires (st'.Peek(1) == 0x1 && st'.Peek(3) == 0x1 && st'.Peek(4) == 0x2f5)
  	// Termination
  	requires st'.Load(0x01) == 4 * 2 // length of "WETH", shifted left.  
	{
		var st := st';
		//|fp=0x0060|0,0x01,0x08,0x01,0x2f5,callSig| 
		st := IsZero(st);
		//|fp=0x0060|1,0x01,0x08,0x01,0x2f5,callSig| 
		st := Push2(st,0x0100);
		//|fp=0x0060|0x0100,1,0x01,0x08,0x01,0x2f5,callSig| 
		assert (st.Peek(0) * st.Peek(1)) <= (MAX_U256 as u256);
		st := Mul(st);
		//|fp=0x0060|0x0100,0x01,0x08,0x01,0x2f5,callSig| 
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		//|fp=0x0060|0x0100,0x01,0x08,0x01,0x2f5,callSig| 
		assert st.Peek(2) == 0x1 && st.Peek(3) == 0x2f5;
		//|fp=0x0060|0x0ff,0x08,0x01,0x2f5,callSig| 
		// ==========================================================
		// NOTE: Reimplemented following to avoid need to reason about bitvector
		// arithmetic.
		// st := And(st);
		if st.Peek(0) == MAX_U256 as u256 { 
			// Masking against MAX_U256 (a nop)
			st := st.Pop().Next();
		} else {
			// Masking against 0xFF
			st := AndU8(st);
		}    
		//|fp=0x0060|0x08,0x01,0x2f5,callSig| 
		st := Push1(st,0x02);
		//|fp=0x0060|0x02,0x08,0x01,0x2f5,callSig| 
		st := Swap(st,1);
		//|fp=0x0060|0x08,0x02,0x01,0x2f5,callSig|
		st := Div(st);
		//|fp=0x0060|0x04,0x01,0x2f5,callSig|
		st := block_0_0x0b46(st);
		return st;
	}

	method block_0_0x0b46(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b46
	// Free memory pointer
	requires st'.MemSize() >= 0x60 && st'.Read(0x40) == 0x60
	// Stack height(s)
	requires st'.Operands() == 4
	// Static stack items
	requires (st'.Peek(0) == 0x4 && st'.Peek(1) == 0x1 && st'.Peek(2) == 0x2f5)
	// Termination
  	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left.  
	{
		var st := st';
		//|fp=0x0060|0x04,0x01,0x2f5,callSig|
		st := Dup(st,1);
		//|fp=0x0060|0x04,0x04,0x01,0x2f5,callSig|
		st := Push1(st,0x1f);
		//|fp=0x0060|0x1f,0x04,0x04,0x01,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		assert (st.Peek(3) == 0x1 && st.Peek(4) == 0x2f5);
		st := Add(st);
		//|fp=0x0060|0x23,0x04,0x01,0x2f5,callSig|
		st := Push1(st,0x20);
		// |fp=0x0060|0x20,0x23,0x4,0x01,0x2f5,callSig|
		st := Dup(st,1);
		// |fp=0x0060|0x20,0x20,0x23,0x4,0x01,0x2f5,callSig|
		st := Swap(st,2);
		// |fp=0x0060|0x23,0x20,0x20,0x4,0x01,0x2f5,callSig|
		st := Div(st);
		// |fp=0x0060|0x01,0x20,0x4,0x01,0x2f5,callSig|
		assert (st.Peek(0) * st.Peek(1)) <= (MAX_U256 as u256);
		st := Mul(st);
		// |fp=0x0060|0x20,0x4,0x01,0x2f5,callSig|   
		assert (st.Peek(0) == 0x20 && st.Peek(1) == 0x4 && st.Peek(2) == 0x1 && st.Peek(3) == 0x2f5);
		st := block_0_0x0b50(st);
		return st;
	}

	method block_0_0x0b50(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b50
	// Free memory pointer
	requires st'.MemSize() >= 0x60 && st'.Read(0x40) == 0x60
	// Stack height(s)
	requires st'.Operands() == 5
	// Static stack items
	requires (st'.Peek(0) == 0x20 && st'.Peek(1) == 0x4 && st'.Peek(2) == 0x1 && st'.Peek(3) == 0x2f5)
	// Termination
  	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left.
  	//requires st'.Peek(0) < 0xffff - 0x80
  	//requires st'.Peek(1) < 0xffff
	{
		var st := st';
		// |fp=0x0060|0x20,0x4,0x01,0x2f5,callSig| 
		st := Push1(st,0x20);
		// |fp=0x0060|0x20,0x20,0x4,0x01,0x2f5,callSig| 
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// |fp=0x0060|0x40,0x4,0x01,0x2f5,callSig| 
		st := Push1(st,0x40);
		// |fp=0x0060|0x40,0x40,0x4,0x01,0x2f5,callSig| 
		st := MLoad(st);
		// |fp=0x0060|0x60,0x40,0x4,0x01,0x2f5,callSig|  i.e. Peek(0) == st'.Read(0x40) == fp
    	assert st.Peek(2) < 0xffff;
		st := Swap(st,1);
		// |fp=0x0060|0x40,0x60,0x4,0x01,0x2f5,callSig| 
		st := Dup(st,2);
		// |fp=0x0060|0x60,0x40,0x60,0x4,0x01,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// |fp=0x0060|0xa0,0x60,0x4,0x01,0x2f5,callSig|
		st := Push1(st,0x40);
		// |fp=0x0060|0x40,0xa0,0x60,0x4,0x01,0x2f5,callSig|   
		assert (st.Peek(0) == 0x40 && st.Peek(1) == 0xa0 && st.Peek(2) == 0x60 && st.Peek(3) == 0x4 && st.Peek(4) == 0x1 && st.Peek(5) == 0x2f5);
		st := block_0_0x0b5b(st);
		return st;
	}

	method block_0_0x0b5b(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b5b
	// Free memory pointer
	requires st'.MemSize() >= 0x60 && st'.Read(0x40) == 0x60
	// Stack height(s)
	requires st'.Operands() == 7
	// Static stack items
	requires (st'.Peek(0) == 0x40 && st'.Peek(1) == 0xa0 && st'.Peek(2) == 0x60 && st'.Peek(3) == 0x04 &&st'.Peek(4) == 0x1 && st'.Peek(5) == 0x2f5)
	// Termination
	//requires (0x80 <= st'.Peek(1) < 0xffff)
  	//requires (st'.Peek(3) < 0xffff)
  	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left. 
  	{
		var st := st';
		// |fp=0x0060|0x40,0xa0,0x60,0x4,0x01,0x2f5,callSig| 
		st := MStore(st);
		// |fp=0x0060|0x60,0x4,0x01,0x2f5,callSig|     // i.e. update fp st.Read(0x40) == 0xa0 // Q: why such a big jump???
    	assert st.Read(0x40) == st'.Peek(1);
		st := Dup(st,1);
		// |fp=0x0060|0x60,0x60,0x4,0x01,0x2f5,callSig|
		st := Swap(st,3);
		// |fp=0x0060|0x01,0x60,0x4,0x60,0x2f5,callSig|
		st := Swap(st,2);
		// |fp=0x0060|0x04,0x60,0x01,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// ||0x60,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// ||0x04,0x60,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// ||0x60,0x04,0x60,0x04,0x01,0x60,0x2f5,callSig|
		st := MStore(st);
		// ||0x60,0x04,0x01,0x60,0x2f5,callSig| i.e st.Read(0x60) == 0x04
		st := block_0_0x0b63(st);
		return st;
	}

	method block_0_0x0b63(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b63
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04
	// Stack height(s)
	requires st'.Operands() == 6
	// Static stack items
	requires (st'.Peek(0) == 0x60 && st'.Peek(1) == 0x04 && st'.Peek(2) == 0x1 && st'.Peek(3) == 0x60 && st'.Peek(4) == 0x2f5)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)
  	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left.  
	{
		var st := st';
		// ||0x60,0x04,0x01,0x60,0x2f5,callSig| 
		st := Push1(st,0x20);
		// ||0x20,0x60,0x04,0x01,0x60,0x2f5,callSig| 
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// ||0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Dup(st,3);
		// ||0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Dup(st,1);
		// ||0x01,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := SLoad(st);
		// ||0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Push1(st,0x01);
		// ||0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Dup(st,2);
		// ||0x08,0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Push1(st,0x01);
		// ||0x01,0x08,0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := block_0_0x0b6e(st);
		return st;
	}

	method block_0_0x0b6e(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b6e
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04          
	// Stack height(s)
	requires st'.Operands() == 11
	// Static stack items
	requires (st'.Peek(0) == 0x1 && st'.Peek(1) == 0x08 && st'.Peek(2) == 0x1 && st'.Peek(3) == 0x08 && st'.Peek(4) == 0x1 && st'.Peek(5) == 0x80 && st'.Peek(6) == 0x4 && st'.Peek(7) == 0x1 && st'.Peek(8) == 0x60 && st'.Peek(9) == 0x2f5)
  	//requires st'.Peek(3) == st'.Load(1)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)
  	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left.  
  {
		var st := st';
		// ||0x01,0x08,0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := AndU1(st);
		// ||0x01,0x08,0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := IsZero(st);
		// ||1,0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Push2(st,0x0100);
		//assert (st.Peek(1) == 0x1 && st.Peek(2) == 0x01 && st.Peek(3) == 0x08 && st.Peek(4) == 0x1 && st.Peek(5) == 0x80 
		//		&& st.Peek(6) == 0x04 && st.Peek(7) == 0x1 && st.Peek(8) == 0x60 && st.Peek(9) == 0x2f5);
		// ||0x100,1,0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(0) * st.Peek(1)) <= (MAX_U256 as u256);
		st := Mul(st);
		// ||0x100,0x01,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		//assert st.Peek(3) == st.Peek(6) == 0x1 && st.Peek(7) == 0x60 && st.Peek(8) == 0x2f5;
		//assert (st.Peek(0) == 0x100 && st.Peek(1) == 0x01 && st.Peek(2) == 0x08 && st.Peek(3) == 0x1 && st.Peek(4) == 0x80 
		//		&& st.Peek(5) == 0x04 && st.Peek(6) == 0x1 && st.Peek(7) == 0x60 && st.Peek(8) == 0x2f5);
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		assert {:split_here} true;
		assert (st.Peek(0) == 0xff && st.Peek(1) == 0x08 && st.Peek(2) == 0x1 && st.Peek(3) == 0x80 
		 		&& st.Peek(4) == 0x04 && st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		// ||0xFF,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		//var x := st.Peek(1);
		//assert st.Peek(0) in {MAX_U256 as u256, 0xFF};
		assert st.Peek(0) == 0xff && st.Peek(1) == 0x08;
   		//assert st.Peek(1) == 4 * 2;
		// ==========================================================
		// NOTE: Reimplemented following to avoid need to reason about bitvector
		// arithmetic.
		// st := And(st);
		if st.Peek(0) == MAX_U256 as u256 { 
			// Masking against MAX_U256 (a nop)
			st := st.Pop().Next();
		} else {
			// Masking against 0xFF
			st := AndU8(st);
			assert (st.Peek(0) == 0x08);
		}
		// ==========================================================
    	//assert st.Peek(0) <= x;
		// ||0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		//assert (st.Peek(0) == 0x08 && st.Peek(1) == 0x1 && st.Peek(2) == 0x80 
		// 		&& st.Peek(3) == 0x04 && st.Peek(4) == 0x1 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		st := Push1(st,0x02);
		//assert (st.Peek(0) == 0x02 && st.Peek(1) == 0x08 && st.Peek(2) == 0x1 && st.Peek(3) == 0x80 
		// 		&& st.Peek(4) == 0x04 && st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		// ||0x02,0x08,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Swap(st,1);
		// ||0x08,0x02,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|   
		assert (st.Peek(0) == 0x08 && st.Peek(1) == 0x2 && st.Peek(2) == 0x1 && st.Peek(3) == 0x80 
				&& st.Peek(4) == 0x04 && st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := block_0_0x0b79(st);
		return st;
	}

	method block_0_0x0b79(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b79
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04     
	// Stack height(s)
	requires st'.Operands() == 9
	// Static stack items
	requires (st'.Peek(0) == 0x08 && st'.Peek(1) == 0x2 && st'.Peek(2) == 0x1 && st'.Peek(3) == 0x80 
				&& st'.Peek(4) == 0x04 && st'.Peek(5) == 0x1 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5)
  	//requires st'.Peek(0) == st'.Load(1)
  	// Termination
	//requires st'.Read(0x60) <= 0xffff
  	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left. 
  {
		var st := st';
		// ||0x08,0x02,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Div(st);
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		//assert (st.Peek(0) == 0x04 && st.Peek(1) == 0x1 && st.Peek(2) == 0x80 
		//	&& st.Peek(3) == 0x04 && st.Peek(4) == 0x1 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		st := Dup(st,1);
		// ||0x04,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := IsZero(st);
		// ||0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		assert st.Peek(0) == 0;
		st := Push2(st,0x0bc6);
		// ||0x0bc6,0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		assume {:axiom} st.IsJumpDest(0xbc6);
		st := JumpI(st);
		if st.PC() == 0xbc6 { // impossible/redundant path
			assert false;
			st := block_0_0x0bc6(st); 
			return st;
		} 
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(0) == 0x04 && st.Peek(1) == 0x1 && st.Peek(2) == 0x80 
			&& st.Peek(3) == 0x04 && st.Peek(4) == 0x1 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		//assert st.Peek(6) == 0x2f5;
		st := Dup(st,1);
		// ||0x04,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Push1(st,0x1f);
		// ||0x1f,0x04,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Lt(st);
		// ||0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|   
		assert (st.Peek(0) == 0 && st.Peek(1) == 0x04 && st.Peek(2) == 0x1 && st.Peek(3) == 0x80 
			&& st.Peek(4) == 0x04 && st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := block_0_0x0b84(st);
		return st;
	}

	method block_0_0x0b84(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b84
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04      
	// Stack height(s)
	requires st'.Operands() == 9
	// Static stack items
  	//requires (st'.Peek(0) in {0,1}) && (st'.Peek(0) == 1 <==> 0x1f < st'.Peek(1))  
	requires (st'.Peek(0) == 0 && st'.Peek(1) == 0x04 && st'.Peek(2) == 0x1 && st'.Peek(3) == 0x80 
			&& st'.Peek(4) == 0x04 && st'.Peek(5) == 0x1 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5)
  	// Termination
 	//requires (st'.Peek(1) == 4)
	//requires (st'.Read(0x60) <= 0xffff)   
	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left. 
	{
		var st := st';
		// ||0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Push2(st,0x0b9b);
		// ||0xb9b,0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		assume {:axiom} st.IsJumpDest(0xb9b);
		st := JumpI(st);
		if st.PC() == 0xb9b { // this path is impossible/redundant
			// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
      		// l >= 0x1f
			//
			// Deadcode begins here.  The reason is that the following code is used
			// to account for copying strings whose length exceeds 31 bytes.
			// However, the actual length of the string involved in this case
			// ("WETH") is only 4 bytes.
      		assert false;
      		st := block_0_0x0b9b(st); 
			return st;
    	}
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Push2(st,0x0100);
		assert st.Peek(3) == 0x80 && st.Peek(5) == 0x01 && st.Peek(7) == 0x2f5;    
		// ||0x100,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Dup(st,1);
		// ||0x100,0x100,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| 
		st := Dup(st,4);
		// ||0x01,0x100,0x100,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := SLoad(st);
		assert st.Peek(7) == 0x01 && st.Peek(8) == 0x60 && st.Peek(9) == 0x2f5;        
		// ||0x08,0x100,0x100,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Div(st);
		assert {:split_here} true;
		//assert (st.Peek(5) == 0x4 && st.Peek(6) == 0x1 && st.Peek(7) == 0x60 && st.Peek(8) == 0x2f5);
		// ||0x0,0x100,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(0) * st.Peek(1)) <= (MAX_U256 as u256);
		st := Mul(st);
		assert {:split_here} true;
		// ||0x0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(0) == 0x0 && st.Peek(1) == 0x4 && st.Peek(2) == 0x1 && st.Peek(3) == 0x80); 
		assert (st.Peek(4) == 0x4 && st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := block_0_0x0b90(st);
		return st;
	}

	method block_0_0x0b90(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b90
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04      
	// Stack height(s)
	requires st'.Operands() == 9
	// Static stack items
	requires (st'.Peek(0) == 0x0 && st'.Peek(1) == 0x4 && st'.Peek(2) == 0x1 && st'.Peek(3) == 0x80 
			&& st'.Peek(4) == 0x4 && st'.Peek(5) == 0x1 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)   
	requires st'.Load(1) == 4 * 2 // length of "WETH", shifted left. 
	{
		var st := st';
		// ||0x0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,4);
		// ||0x80,0x0,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := MStore(st);
		assert {:split_here} true;
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig| i.e st.Read(0x80) == 0x0
		st := Swap(st,2);
		// ||0x80,0x01,0x04,0x04,0x01,0x60,0x2f5,callSig|
		st := Push1(st,0x20);
		// ||0x20,0x80,0x01,0x04,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// ||0xa0,0x01,0x04,0x04,0x01,0x60,0x2f5,callSig|
		assert {:split_here} true;
		st := Swap(st,2);
		// ||0x04,0x01,0xa0,0x04,0x01,0x60,0x2f5,callSig|
		st := Push2(st,0x0bc6);
		// ||0xbc6,0x04,0x01,0xa0,0x04,0x01,0x60,0x2f5,callSig|
		assume {:axiom} st.IsJumpDest(0xbc6);
		st := Jump(st);
		// ||0x04,0x01,0xa0,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		st := block_0_0x0bc6(st);
		return st;
	}

	method block_0_0x0b9b(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0b9b
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  
	// Stack height(s)
	requires st'.Operands() == 8
	// Static stack items
	requires (st'.Peek(0) == 0x4 && st'.Peek(1) == 0x1 && st'.Peek(2) == 0x80 && st'.Peek(3) == 0x4 && st'.Peek(4) == 0x1 
			&& st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5)
  	// Termination
  	//requires  // "WETH"
	//requires (st'.Read(0x60) <= 0xffff)    
	{
		var st := st';
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := JumpDest(st);
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,3);
		// ||0x80,0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		assert st.Peek(0) == 0x84 && st.Peek(1) == 0x01 && st.Peek(2) == 0x80 && st.Peek(3) == 0x4 
				&& st'.Peek(4) == 0x1 && st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5;
		assert {:split_here} true;
		var n := st.Peek(0);
		// ||0x84,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Swap(st,2);
		// ||0x80,0x01,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// ||0x1,0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Push1(st,0x00);
		// ||0x0,0x1,0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := MStore(st);
		assert {:split_here} true;
		assert st.Read(0x0) == 0x1;
		// ||0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig| i.e. st.Read(0x0)=1
		st := Push1(st,0x20);
    	// ||0x20,0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|   
		assert st.Peek(0) == 0x20 && st.Peek(1) == 0x80 && st.Peek(2) == 0x84 && st.Peek(3) == 0x4 
				&& st'.Peek(4) == 0x1 && st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5;
		st := block_0_0x0ba5(n,st); 
		return st;
	}

	method block_0_0x0ba5(n: u256, st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0ba5
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  //&& st'.Read(0x0) == 0x1
	// Stack height(s)
	requires st'.Operands() == 8
	// Static stack items
	requires (st'.Peek(0) == 0x20 && st'.Peek(1) == 0x80 && st'.Peek(2) == n == 0x84 && st'.Peek(3) == 0x4
			&& st'.Peek(4) == 0x1 && st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)  
  	//requires (0x80 <= st'.Peek(2) == n < 0xffff)
	{
		var st := st';
		// ||0x20,0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|  
		st := Push1(st,0x00);
		// ||0x0,0x20,0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|  
		st := Keccak256(st);
		// ||hash,0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|  
		st := Swap(st,1);
		// ||i==0x80,hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig| 
		assert st.Peek(0) == 0x80 && st.Peek(2) == 0x84 && st.Peek(3) == 0x4 
				&& st'.Peek(4) == 0x1 && st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5;
		st := block_0_0x0ba9(0x80,n,st);
		return st;
	}

	method block_0_0x0ba9(i: u256, n: u256, st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0ba9
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  //&& st'.Read(0x0) == 0x1
	// Stack height(s)
	requires st'.Operands() == 8
	// Static stack items
	requires (st'.Peek(0) == i && st'.Peek(2) == n && st'.Peek(4) == 0x1 && st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)
	requires 0x80 <= i <= n < 0xffff
	decreases n-i,2
	{
		var st := st';
		// ||i==0x80,hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := JumpDest(st);
		// ||i==0x80,hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,2);
		assert st.Peek(0) == st'.Peek(1);
		// ||hash,i==0x80,hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := SLoad(st);
		// ||SLoad(hash),i==0x80,hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,2);
		// ||i,SLoad(hash),i==0x80,hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := MStore(st);
		assert {:split_here} true;
		assert (st.Peek(0) == i && st.Peek(2) == n && st.Peek(4) == 0x1 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
		// ||i==0x80,hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig| i.e. st.Read(i) == SLoad(hash), initially i == 0x80
		st := Swap(st,1);
		// ||hash,i==0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Push1(st,0x01);
		// ||0x01,hash,i==0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		//assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256); // Q: cannot prove but redundant???
		st := Add(st);
		// ||0x01+hash,i==0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := block_0_0x0bb2(i,n,st);
		return st;
	}

	method block_0_0x0bb2(i: u256, n: u256, st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0bb2
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  //&& st'.Read(0x0) == 0x1
	// Stack height(s)
	requires st'.Operands() == 8
	// Static stack items
	requires (st'.Peek(1) == i && st'.Peek(2) == n && st'.Peek(4) == 0x1 && st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)
	requires 0x80 <= i <= n < 0xffff
	decreases n-i,1
	{
		var st := st';
		// ||0x01+hash,i==0x80,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Swap(st,1);
		// ||i==0x80,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Push1(st,0x20);
		// ||0x20,i==0x80,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		//assert st.Peek(5) == 0x01;
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// ||0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,1);
		// ||0xa0,0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,4);
		// ||n==0x84,i'==0xa0,i'==0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Gt(st);
		// ||n>i,i'==0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		//assert (st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := block_0_0x0bb9(i+0x20,n,st);
		return st;
	}

	method block_0_0x0bb9(i: u256, n: u256, st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0bb9
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  //&& st'.Read(0x0) == 0x1
	// Stack height(s)
	requires st'.Operands() == 9
	// Static stack items
	requires (st'.Peek(5) == 0x1 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5)
  	requires (st'.Peek(0) in {0,1}) && (st'.Peek(0) == 0 <==> n <= i)
	requires (st'.Peek(1) == i && st'.Peek(3) == n)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)
  	requires n < 0xffff && 0xA0 <= i <= (n+0x20)
	decreases n+0x20-i,0  
	{
		var st := st';
		// ||n>i,i'==0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Push2(st,0x0ba9);
		// ||0xba9,n>i,i'==0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		assume {:axiom} st.IsJumpDest(0xba9);
		st := JumpI(st);
		if st.PC() == 0xba9 { 
			// n > i 
			// ||i'==0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
			assert (st.Peek(0) == i && st.Peek(2) == n && st.Peek(4) == 0x1 && st.Peek(5) == 0x60 && st.Peek(6) == 0x2f5);
			st := block_0_0x0ba9(i,n,st); 
			return st;
		}
		// n <= i 
		// ||i'==0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Dup(st,3);
		// ||n==0x84,i'==0xa0,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := Swap(st,1);
		// ||i'==0xa0,n==0x84,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		assert st.Peek(1) <= st.Peek(0);
		st := Sub(st);
		// ||i-n,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Push1(st,0x1f);
		// ||0x1f,i-n,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := AndU5(st);
		// ||0x1f&i-n,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		assert st.Peek(0) <= 0x1f;
		st := Dup(st,3);
		// ||n==0x84,0x1f&i-n,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(5) == 0x1 && st.Peek(6) == 0x60 && st.Peek(7) == 0x2f5);
		st := block_0_0x0bc4(st);
		return st;
	}

	method block_0_0x0bc4(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0bc4
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04  //&& st'.Read(0x0) == 0x1
	// Stack height(s)
	requires st'.Operands() == 9
	// Static stack items
	requires st'.Peek(0) <= 0xffff && st'.Peek(1) <= 0x1f
	requires (st'.Peek(5) == 0x1 && st'.Peek(6) == 0x60 && st'.Peek(7) == 0x2f5)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)  
	{
		var st := st';
		// ||n==0x84,0x1f&i-n,0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		assert (st.Peek(0) + st.Peek(1)) <= (MAX_U256 as u256);
		st := Add(st);
		// ||n+(0x1f&i-n),0x01+hash,n==0x84,0x04,0x01,0x60,0x2f5,callSig|
		st := Swap(st,2);
		// ||n==0x84,0x01+hash,n+(0x1f&i-n),0x04,0x01,0x60,0x2f5,callSig|
		st := block_0_0x0bc6(st);
		return st;
	}

	// from b79 (dead path):	||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
	// from b90:				||0x04,0x01,0xa0,0x04,0x01,0x60,0x2f5,callSig|
	// from bc4 (dead Path): 	||n,0x01+hash,n+(0x1f&i-n),0x04,0x01,0x60,0x2f5,callSig|
	method block_0_0x0bc6(st': EvmState.ExecutingState) returns (st'': EvmState.State)
	requires st'.evm.code == Code.Create(BYTECODE_0)
	requires st'.WritesPermitted() && st'.PC() == 0x0bc6
	// Free memory pointer
	requires st'.MemSize() >= 0x80 && st'.Read(0x40) == 0xa0 && st'.Read(0x60) == 0x04 //&& st'.Read(0x80) == 0x0  
	// Stack height(s)
	requires st'.Operands() == 8
	// Static stack items
	requires (st'.Peek(5) == 0x60 && st'.Peek(6) == 0x2f5)
  	// Termination
	//requires (st'.Read(0x60) <= 0xffff)  
	{
		var st := st';
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := JumpDest(st);
		// ||0x04,0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Pop(st);
		// ||0x01,0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Pop(st);
		// ||0x80,0x04,0x01,0x60,0x2f5,callSig|
		st := Pop(st);
		// ||0x04,0x01,0x60,0x2f5,callSig|
		st := Pop(st);
		// ||0x01,0x60,0x2f5,callSig|
		st := Pop(st);
		// ||0x60,0x2f5,callSig|
		st := Dup(st,2);
		// ||0x2f5,0x60,0x2f5,callSig|
		assume {:axiom} st.IsJumpDest(0x2f5);
		st := Jump(st);
		// ||0x2f5,0x60,0x2f5,callSig|
		st := block_0_0x02f5(st);
		return st;
	}

}
